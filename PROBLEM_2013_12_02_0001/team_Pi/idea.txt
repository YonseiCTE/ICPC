1. 
  가) Heap Sort를 이용하여 for문 한번에 걸쳐 데이터를 정렬한다.
  나) 정렬하면서 데이터가 갖고 있던 인덱스를 크기 순으로 정렬한다.
    ex) 데이터         : 50 90 10 20 40
        정렬 된 데이터 : 90 50 40 20 10
        정렬 된 인덱스 : 1  0  4  3  2


2.
  Weak_Key인지 알아본다.
  정렬 된 인덱스가 연속적이면 한 묶음으로 묶고, 묶음이 4개 이상일 시 Weak_Key로 판별한다.
  
  ex ) 정렬 된 인덱스 : 1 2 3 4 5
       묶는 과정      : (1~2)
                      : (1~3)
                      : (1~4)
                      : (1~5)
       
       정렬 된 인덱스 : 5 3 4 1 2
       묶는 과정      : (5) (3)
                      : (5) (3~4)
                      : (3~5)
                      : (3~5) (1)
                      : (3~5) (1~2)
                      : (1~5)
                      
  묶음이 4개 이상일 경우에만 Weak_Key라는 것은 아래의 증명을 따라 '참'임을 알 수 있다.
  
    가)묶음이 하나가 될 경우
    
    => 묶음이 하나라면 4가지 경우로 따져봐야 한다.


      1) 처음부터 끝까지 한 묶음이 될 경우
        ex ) 1 2 3 4 5
             4 5 3 2 1


        => 2 > 4 > 1 > 3 을 만족해야 Weak_Key 이다.
           하지만 묶는 과정을 바라볼 때, 다음 원소를 만나면 그 원소는 무조건 묶음의 가장 작은 값 보다
           1만큼 작거나, 가장 큰 값 보다 1만큼 더 크다.
           따라서 2 > 4 > 1 을 만족시키고, 2 > 4 > 1 > 3이 만족 되는 '3' 값이 존재 할 수 없다.
           
           2 < 4 < 1 < 3 의 경우에도 마찬가지다.
           이 경우에도 4 < 1 < 3 을 만족시키고, 2 < 4 < 1 < 3이 만족 되는 '2' 값이 존재 할 수 없다.
           
      
      2) 묶는 과정에서 두 묶음이 한 묶음이 되는 경우
        ex ) 1 2 3 5 4
        
        => 두 묶음이 한 묶음이 될 때, 2 > 4 > 1 > 3의 패턴이 있는지 확인해 보자.
           (x~y) (u~v)
           위와 같이 두 묶음이 있다면 앞의 묶음에 반드시 '2'가 포함 되어야 한다.
           하지만 '4'는 앞 묶음에 포함 되지 못하는 것을 금방 파악 할 수 있다.
           그렇다면 뒤 묶음에 4 > 1 > 3의 패턴이 가능해야 하지만, 이또한 불가능하다.
           '2'가 앞 묶음에 포함되어야 하기 때문이다.
           
           이번엔 2 < 4 < 1 < 3의 경우를 따져보자.
           이번엔 앞 묶음에 반드시 '3'이 포함되어야 한다.
           하지만 '1'이 앞 묶음에 포함 되지 못하는 것을 파악 할 수 있다.
           그렇다면 뒤 묶음에 2 < 4 < 1의 패턴이 가능해야 하지만, 위와 같은 사례로 불가능함을 알 수 있다.
           
      3) 묶는 과정에서 세 묶음이 한 묶음이 되는 경우
        ex) 1 2 5 6 3 4
        
        => 세 묶음이 한 묶음이 될 때, 2 > 4 > 1 > 3의 패턴이 있는지 확인해 보자.
           (x~y) (u~v) (i~j)
           위와 같이 세 묶음이 있다면 가장 앞의 묶음에 반드시 '2'가 포함 되어야 한다. (뒤의 두 묶음으로 패턴이 불가능 하므로!)
           하지만 두 묶음이 4 > 1 > 3 패턴을 가질 수 없다. 그 이유는 4 > 1 > 3 패턴을 가지려면 어쨋든 두 묶음 중에
           한 묶음이 '2'를 포함해야 하기 때문이다.
           
           다음은 2 < 4 < 1 < 3의 패턴이 있는지 확인해 보자.
           이번엔 가장 앞 묶음에 반드시 '3'이 포함되어야 한다.
           하지만 2 < 4 < 1 패턴을 나머지 두 묶음이 가질 수 없다. 이유는 위와 비슷하다.
           
      4) 묶는 과정에서 네 묶음 이상이 한 묶음이 되는 경우
        ex) 1 2 7 8 3 4 5 6


      => 만약 네 묶음일이 한 묶음이 될 경우엔 2 > 4 > 1 > 3의 패턴을 생각 했을 때, 맨 앞의 묶음이 반드시 '2'를
         포함해야 한다.
         나머지 세 묶음의 맨 앞 묶음도 반드시 '4'를 포함해야 한다.
         하지만 1 > 3 패턴을 나머지 두 묶음이 가질 수가 없다.
         '2'를 함께 포함해야 하기 때문이다.
         이는 4보다 큰 묶음에도 모두 적용 된다.
         
         위와 비슷한 경우로 2 < 4 < 1 < 3도 적용 된다.


    나)묶음이 둘, 셋이 되는 경우도 위와 비슷하게 생각하면 Weak_Key가 아님을 알 수 있다.
    
    다)묶음이 넷 이상이 될 경우
    
    => 이경우엔 2 > 4 > 1 > 3 혹은 2 < 4 < 1 < 3 이 반드시 적용된다.
       묶음이 넷이 될 경우를 생각해 보자.
       각 묶음은 서로 인접한 묶음과 연속적이지 않다.
       그런데, 연속적이지 않으면서 네 묶음이 되는 경우는 맨 앞의 묶음이 2, 다음 묶음이 4, 다음이 1, 마지막이 3을
       포함하는 경우와 맨 앞의 묶음이 3, 다음 묶음이 1, 다음이 4, 마지막이 2를 포함하는 경우 밖에 없음을 알 수 있다.
       따라서, 네 묶음이 되면 반드시 Weak_Key이다.
       
       네 묶음보다 클 경우는 네 묶음을 포함하는 경우이므로 반드시 Weak_Key이다.
       
3.
  Weak_Key인지 알아보는 방법 또한 for문 한번에 걸쳐 코딩이 가능하다.
  
  Stack을 활용하여 각 묶음의 최소 값, 최대 값을 push를 해 놓는다.
  각 묶음의 연속성을 알아 볼 때에는 pop을 이용하여 각 묶음의 최대 값과 최소 값을 활용해 알아보면 된다.
  
  원소를 추가 할 때에는 마지막 묶음의 최소 값, 최대 값과 비교하여 연속성을 따지면 되겠다.

