1.
 로봇이 도착지점을 찾는 경우는 2가지로 나누어 볼 수 있다.


  ㄱ. 열린 길('.')을 따라가다가 도착지점('T')을 찾는 경우.
  ㄴ. 벽('*')을 뚫으며 가다가 도착지점을 찾는 경우.


2.
 그렇다면 '열린 길'을 찾았을 때, 현재 가지고 있는 energy 잔여 수를 저장시켜 문제를 해결 할 수 있다.
 예를 들어, 


         S . . . .
         * * * * *
         * * * * .
         * * * * T


 와 같이 미로가 있다고 하자.
 시작 전, energy를 '1'만큼 가지고 있었다고 하면, 'S' 오른쪽 길은 다음과 같아진다.


         S 1 1 1 1
         * * * * *
         * * * * .
         * * * * T


 출발 전, 가지고 있던 energy 수가 1이기 때문에 'S' 오른쪽의 모든 길은 '1'만큼의 energy를 가지고 있다.
 하지만 S 줄의 가장 오른쪽 길에서 더이상 갈 길이 없다는 것을 알 수 있다.
 이 때 가장 energy를 적게 소모하여 갈 수 있는 길을 찾는다.
 위의 지도로 보면 벽을 딱 하나만 뚫고 지나갈 수 있는 길이 있다는 것을 알 수 있다.
 운이 좋게도 현재 위치하고 있는 곳('S' 줄의 가장 오른쪽 지점)의 energy 잔여수가 그림과 같이 '1'이므로
 energy 하나로 뚫고 지나 갈 수 있다.
 그렇다면 지도는 이런식으로 바뀌게 된다.


         S 1 1 1 1
         * * * * *
         * * * * 0
         * * * * T


 그리고 도착한 곳에서 T를 찾아 갈 수 있으므로
 'y'를 출력하고 프로그램을 끝낸다.


3.
 예외 사항을 알아보자.


         S . . . .
         . * * * *
         . * * * *
         . * * * *
         . . . * T


 시작지점에서 오른쪽으로 먼저 이동했다고 생각하면,


         S 1 1 1 1
         . * * * *
         . * * * *
         . * * * *
         . . . * T


 위와 같이 된다.
 하지만, '1'이 표시된 지점에서 다른 길로 갈 수 있는 방안은 S의 아래쪽 길이지만 energy가 0이되어


         S 1 1 1 1
         0 * * * *
         0 * * * *
         0 * * * *
         0 0 0 * T


 도착지점에 도달할 수 없게 된다.
 따라서 Stack을 이용해야 함을 알 수 있다.
 길을 다닐 때마다 거쳤던 길을 모두 Stack에 push 해 놓는다.
 그리고 위의 그림과 같이 더이상 갈 곳이 없고, 벽을 뚫어 다른 곳으로도 이동하지 못할 때, pop을
 이용하여 다음 길을 찾아본다.
 따라서 다시 'S'까지 pop을 총 '10'회 하게 되며 energy는 'S'의 가장 오른쪽 길이 가지고 있는 '1'로
 중간에 변경되어야 한다.
 'S'에서 오른쪽 길은 이미 가봤으므로 이젠 아래 길을 찾아야 한다. 또한 energy는 다시 '1'로 충전되어 있다.
 하지만, 아래 길도 이미 가보지 않았던가? 그래서 이미 가 봤던 길을 또 다시 갈 수 있는지에 대한 방안은
 '4'번에 적혀 있다.
 어쨋든 'S' 아래 방향으로 이동하게 되면 아래 그림처럼 된다는 것을 알 수 있다.


         S 1 1 1 1
         1 * * * *
         1 * * * *
         1 * * * *
         1 1 1 * T


 'T' 왼쪽의 벽을 부시면 도달 할 수 있음을 알 수 있다.


4.
 또 다른 예외 사항을 알아보자.


 벽을 뚫고 가장 가까운 길을 찾아갈 때는 다음을 고려해야 한다.


         2 2 2 2 * *
         * * * * * *
         * 3 3 3 3 *
         * * * * * *


 위의 그림을 잘 생각해 보자.
 만약 energy 잔여 수가 '2'인 길에서 '3'인 길로 벽을 뚫고 가려고 한다면, 중지시켜야 한다.
 이미 '3'인 길은 energy가 '3'일 때 방문 했었기 때문이다.
 '2'인 길에서 '3'인 길로 가게 된다면 '3'인 길은 '1'로 변경이 된다. 그렇다면 '3'일 때도
 도착지점을 찾지 못했기 때문에 헛수고가 된다.
 따라서 벽을 뚫고 새로운 길을 찾아 이동할 때는 그 지점의 energy 잔여수보다 이동 했을 때의 잔여 수가
 더 큰 경우에만 이동한다.


         5 5 5 5 * *
         * * * * * *
         * 3 3 3 3 *
         * * * * * *


 위의 그림과 같을 때는 '5'에서 '3'으로 이동하는 것이 맞다. '3'인 길에서 도착지점을 찾진 못했지만, '5'에서
 '3'으로 이동하면 '3'인 길은 '4'로 변하게 된다. energy 하나 차이로 도착지점을 못 찾은 경우도 있을 수
 있으므로 확인하는 것이 맞다.

5.
 우리 팀에서 제공한 Maze_Robot.cpp 파일을 살펴보면 Map을 카피 할 때, '='로 벽을 쳐서 copy 했음을 알 수 있다.
 먄약


	 S .
	 . T
         
 와 같은 맵을 copy 할 때,
 
	 = = = =
         = S . =
         = . T =
         = = = =
 
 로 복사 하였는데, 굳이 겉에 벽을 칠 필요가 없음을 알 수 있었다.
 물론, 사람마다 코딩 방식이 다르니 필요할 수도 있겠지만 말이다.

6.
 그렇다면 도대체 어떤 식으로 도착지점에 도달할 수 있음을 알 수 있을까?
 식을 간단히 표현하는 것으로 idea를 끝내겠다.
 M : 행
 N : 열


 Current_energy : 현재 위치에서의 energy 잔여 수
 Current_M : 현재 위치의 M 값
 Current_N : 현재 위치의 N 값
 T_M : 도착지점의 M 값
 T_N : 도착지점의 N 값


 abs (T_M - Current_M) + abs (T_N - Current_N) - 1 <= Current_energy

